#include "cpuid.h"

cpu_t cpu_info;

/* cpuid_t cpuid(int32_t eax)
 * @input: eax - parameter for CPUID instruction
 * @output: ret val - eax, ebx, ecx, edx generated by CPUID instruction
 * @description: a wrapper for CPUID instruction.
 */
cpuid_t cpuid(int32_t eax) {
    cpuid_t ret;
    asm volatile("cpuid"
                 : "=a"(ret.eax), "=b"(ret.ebx), "=c"(ret.ecx), "=d"(ret.edx)
                 : "a"(eax)
    );
    return ret;
}

/* void cpuid_init()
 * @output: set the cpu_info global variable
 * @description: fetches and formats data of CPU using CPUID instruction,
 *     read https://c9x.me/x86/html/file_module_x86_id_45.html for what the codes are about.
 */
void cpuid_init() {
    // Handle cpuid 0
    cpuid_t ret = cpuid(0);
    cpu_info.max_id_basic = ret.eax;
    memset(cpu_info.brand, 0, CPUID_BRAND_NAME_LEN + 1);
    int32_t mask;
    int32_t i = 0;
    for(mask = 0; mask < 32; mask += 8) cpu_info.brand[i++] = ((ret.ebx >> mask) & 0xff);
    for(mask = 0; mask < 32; mask += 8) cpu_info.brand[i++] = ((ret.edx >> mask) & 0xff);
    for(mask = 0; mask < 32; mask += 8) cpu_info.brand[i++] = ((ret.ecx >> mask) & 0xff);
    // puts(cpu_info.brand);

    // Handle cpuid 1
    if(cpu_info.max_id_basic >= 1) {
        ret = cpuid(1);
        cpu_info.version.val = ret.eax;
        cpu_info.topology.val = ret.ebx;
        cpu_info.features_ext.val = ret.ecx;
        cpu_info.features.val = ret.edx;
    }

    // Handle cpuid 2
    if(cpu_info.max_id_basic >= 2) {
        ret = cpuid(2);
        int8_t max_times = ret.eax & 0xff;
        if(max_times > CPUID_CACHE_MAX_LOOP) max_times = CPUID_CACHE_MAX_LOOP;
        int offset = 0;
        memset(cpu_info.cache, 0, CPUID_CACHE_INFO_LEN);
        for(i = 0; i < max_times; i++) {
            ret = cpuid(2);
            if(0 == (ret.eax & 0x80000000)) {
                for(mask = 8; mask < 32; mask += 8) cpu_info.cache[offset++] = ((ret.eax >> mask) & 0xff);
            }
            if(0 == (ret.ebx & 0x80000000)) {
                for(mask = 0; mask < 32; mask += 8) cpu_info.cache[offset++] = ((ret.ebx >> mask) & 0xff);
            }
            if(0 == (ret.ecx & 0x80000000)) {
                for(mask = 0; mask < 32; mask += 8) cpu_info.cache[offset++] = ((ret.ecx >> mask) & 0xff);
            }
            if(0 == (ret.edx & 0x80000000)) {
                for(mask = 0; mask < 32; mask += 8) cpu_info.cache[offset++] = ((ret.edx >> mask) & 0xff);
            }
        }
    }

    // CPUID 3 is for Pentium III only, not implemented

    // Handle cpuid 4
    if(cpu_info.max_id_basic >= 4) {
        ret = cpuid(4);
        cpu_info.cache_detail.val = ret.eax;
        cpu_info.topology_detail.val = ret.ebx;
        cpu_info.num_of_sets = ret.ecx;
    }

    // Handle cpuid 5
    if(cpu_info.max_id_basic >= 5) {
        ret = cpuid(5);
        cpu_info.min_mon_line_size = (uint16_t) ret.eax;
        cpu_info.max_mon_line_size = (uint16_t) ret.ebx;
    }

    // Handle cpuid extended 0
    ret = cpuid(0x80000000);
    cpu_info.max_id_extended = ret.eax & 0x7fffffff;

    // Handle cpuid extended 2-5, processor brand string
    memset(cpu_info.brand_str, 0, CPUID_BRAND_STR_LEN + 1);
    if(cpu_info.max_id_extended >= 4) {
        i = 0;
        ret = cpuid(0x80000002);
        for(mask = 0; mask < 32; mask += 8) cpu_info.brand_str[i++] = ((ret.eax >> mask) & 0xff);
        for(mask = 0; mask < 32; mask += 8) cpu_info.brand_str[i++] = ((ret.ebx >> mask) & 0xff);
        for(mask = 0; mask < 32; mask += 8) cpu_info.brand_str[i++] = ((ret.ecx >> mask) & 0xff);
        for(mask = 0; mask < 32; mask += 8) cpu_info.brand_str[i++] = ((ret.edx >> mask) & 0xff);
        ret = cpuid(0x80000003);
        for(mask = 0; mask < 32; mask += 8) cpu_info.brand_str[i++] = ((ret.eax >> mask) & 0xff);
        for(mask = 0; mask < 32; mask += 8) cpu_info.brand_str[i++] = ((ret.ebx >> mask) & 0xff);
        for(mask = 0; mask < 32; mask += 8) cpu_info.brand_str[i++] = ((ret.ecx >> mask) & 0xff);
        for(mask = 0; mask < 32; mask += 8) cpu_info.brand_str[i++] = ((ret.edx >> mask) & 0xff);
        ret = cpuid(0x80000004);
        for(mask = 0; mask < 32; mask += 8) cpu_info.brand_str[i++] = ((ret.eax >> mask) & 0xff);
        for(mask = 0; mask < 32; mask += 8) cpu_info.brand_str[i++] = ((ret.ebx >> mask) & 0xff);
        for(mask = 0; mask < 32; mask += 8) cpu_info.brand_str[i++] = ((ret.ecx >> mask) & 0xff);
        for(mask = 0; mask < 32; mask += 8) cpu_info.brand_str[i++] = ((ret.edx >> mask) & 0xff);
    }
}

// Unified FS interface for reading CPUID information
unified_fs_interface_t cpuid_if = {
    .open = cpuid_open,
    .read = cpuid_read,
    .write = cpuid_write,
    .close = cpuid_close
};

/* int32_t cpuid_open(int32_t* inode, char* filename)
 * @input: all ignored
 * @output: success
 * @description: does nothing.
 */
int32_t cpuid_open(int32_t* inode, char* filename) {
    return 0;
}

// Macro for simplifying appending a string to overall buffer.
#define APPEND_BUFFER(str)                  \
    memcpy(tmp + pos, str, strlen(str));    \
    pos += strlen(str);

// Macro for simplifying checking multiple features and adding them to string.
#define CHECK_FEATURE(feature, str)         \
    if(feature) {                           \
        memcpy(tmp + pos, str, strlen(str));\
        pos += strlen(str);                 \
    }

/* int32_t cpuid_read(int32_t* inode, uint32_t* offset, char* buf, uint32_t len)
 * @input: offset - num of attribute we're outputting
 *         buf - buffer to write to
 *         len - max number of characters to write into
 * @output: buf - written with CPU information
 *          ret val - 0 (SUCCESS) / -1 (FAIL)
 * @description: formats CPU information and writes them into buffer.
 */
int32_t cpuid_read(int32_t* inode, uint32_t* offset, char* buf, uint32_t len) {
    if(len < CPUID_FS_BUF) return FAIL;
    char tmp[CPUID_FS_BUF];
    char tmp2[CPUID_FS_BUF];
    memset(tmp, 0, CPUID_FS_BUF);
    memset(tmp2, 0, CPUID_FS_BUF);
    int pos = 0;
    switch(*offset) {
        case 0:
            APPEND_BUFFER(cpu_info.brand);
            tmp[pos++] = ' ';
            APPEND_BUFFER(cpu_info.brand_str);
            tmp[pos++] = '\n';
            break;
        case 1:
            APPEND_BUFFER("Family ");
            itoa((cpu_info.version.ext_family_id << 4) | cpu_info.version.family_id, tmp2, 16);
            APPEND_BUFFER(tmp2);
            tmp[pos++] = ',';
            tmp[pos++] = ' ';
            break;
        case 2:
            APPEND_BUFFER("Model ");
            itoa((cpu_info.version.ext_model_id << 4) | cpu_info.version.model_id, tmp2, 16);
            APPEND_BUFFER(tmp2);
            tmp[pos++] = ',';
            tmp[pos++] = ' ';
            break;
        case 3:
            APPEND_BUFFER("Stepping ");
            itoa(cpu_info.version.stepping_id, tmp2, 16);
            APPEND_BUFFER(tmp2);
            tmp[pos++] = '\n';
            break;
        case 4:
            APPEND_BUFFER("Features: ");
            CHECK_FEATURE(cpu_info.features.fpu,        "FPU ");
            CHECK_FEATURE(cpu_info.features.pae,        "PAE ");
            CHECK_FEATURE(cpu_info.features.acpi,       "ACPI ");
            CHECK_FEATURE(cpu_info.features.apic,       "APIC ");
            CHECK_FEATURE(cpu_info.features.mmx,        "MMX ");
            CHECK_FEATURE(cpu_info.features.sse,        "SSE ");
            CHECK_FEATURE(cpu_info.features.sse2,       "SSE2 ");
            CHECK_FEATURE(cpu_info.features_ext.sse3,   "SSE3 ");
            CHECK_FEATURE(cpu_info.features.htt,        "HyperThread ");
            CHECK_FEATURE(cpu_info.features_ext.est,    "EnhancedSpeedStep ");
            tmp[pos++] = '\n';
            break;
    }
    (*offset) ++;
    memcpy(buf, tmp, strlen(tmp) + 1);
    return strlen(tmp);
}

/* int32_t cpuid_write(int32_t* inode, uint32_t* offset, const char* buf, uint32_t len)
 * @input: buf - value of new frequency for RTC
 *         len - length of buf, should be sizeof(uint16_t)
 * @output: -1 (FAIL)
 * @description: does nothing, cannot change CPU attribute by software
 */
int32_t cpuid_write(int32_t* inode, uint32_t* offset, const char* buf, uint32_t len) {
    return FAIL;
}

/* int32_t cpuid_close(int32_t* inode)
 * @input: inode - ignored
 * @output: 0 (SUCCESS)
 * @description: close CPUID, currently does nothing
 */
int32_t cpuid_close(int32_t* inode) {
    return SUCCESS;
}
